<html>
<head>
<title>PropositionDefinition</title>
</head>
<body bgcolor="#ffffff" topmargin=0 marginheight=0>
<a href="index.html">home</a>
<style type="text/css">

table#structureMetaTable {
border-collapse:collapse;
border:1px solid #000000;
width:95%;
}
table#structureMetaTable th.h {
border:1px solid #000000;
background-color:#eeeeee;
width:15%;
}
table#structureMetaTable td#structureName {
border:1px solid #000000;
width:85%;
}
table#structureMetaTable td#structureVersion {
border:1px solid #000000;
width:70%;
}
table#structureMetaTable td#structureVersionHistory {
border:1px solid #000000;
width:15%;
}

</style>
<style type="text/css">

table.structTable {
border-collapse:collapse;
border:1px solid #000000;
width:95%;
}

table.structTable td.d {
border:1px solid #000000;
}

table.structTable th.h {
border:1px solid #000000;
background-color:#eeeeee;
}

table.structTable td.structSName {
border:1px solid #000000;
background-color:#f2f2f2;
color:#222222;
text-align:left;
vertical-align:top;
font-weight:bold;
font-style:italic;

}

table.structTable td.structLName {
border:1px solid #000000;
background:#ffffff;
vertical-align:top;

}

table.structTable td.structType {
border:1px solid #000000;
background:#ffffff;
vertical-align:top;
font-style:italic;

}

table.structTable td.structDesc {
border:1px solid #000000;
background:#ffffff;
vertical-align:top;

}

table.structTable td.structOpt {
border:1px solid #000000;
background:#ffffff;
vertical-align:top;
text-align: center;
}

table.structTable td.structReq {
border:1px solid #000000;
background:#ccccff;
vertical-align:top;
text-align: center;
}


table.structTable td.structCard {
border:1px solid #000000;
background:#ffffff;
vertical-align:top;
text-align: center;
}

table.structTable td.structAttr {
border:1px solid #000000;
background:#ffffff;
vertical-align:top;
text-align: center;
}

table.structTable td.structElem {
border:1px solid #000000;
background:#ccccff;
vertical-align:top;
text-align: center;
}

table.structTable td.structStatus {
border:1px solid #000000;
background:#ffffff;
vertical-align:top;
text-align: center;

}

table.structTable td.commentsDesc {
border:1px solid #000000;
background:#ffffff;
vertical-align:top;

}


</style>
<h1>PropositionDefinition</h1>
<table id="structureMetaTable">
<tr>
<th class=h>Name</th>
<td id=structureName colspan=2>PropositionDefinition</td>
</tr>
<tr>
<th rowspan=3 class=h>Usage</th>
<td id="structureVersion" colspan=2><a href="RuleRepositoryService.html">RuleRepositoryService</a>
<a href=" PropositionBoService.html"> PropositionBoService</a>
</td></tr>
<tr>
<td id="structureVersion" colspan=2><a href="PropositionBoService.html#PropositionBo-createProposition">createProposition</a>
<a href="PropositionBoService.html#PropositionBo-updateProposition">updateProposition</a>
<a href="PropositionBoService.html#PropositionBo-getPropositionById">getPropositionById</a>
</td></tr>
<tr>
<td id="structureVersion" colspan=2><a href="RuleDefinition.html">RuleDefinition</a>
<a href="PropositionDefinition.html">PropositionDefinition</a>
</td></tr>
<th class=h>Type</th>
<td id=structureVersion colspan=2>Complex</td>
</tr>
</table>
<h2>Description</h2>
Concrete model object implementation of KRMS Proposition. <br>Immutable. <br>Instances of Proposition can be (un)marshalled to and from XML.<br><br>There are three main types of Propositions:<br>   1. Compound Propositions - a proposition consisting of other propositions<br>   	 and a boolean algebra operator (AND, OR) defining how to evaluate those propositions.<br>   2. Parameterized Propositions - a proposition which is parameterized by some set of values, <br>   	 evaluation logic is implemented by hand and returns true or false<br>   3. Simple Propositions - a proposition of the form lhs op rhs where <br>   	lhs=left-hand side, rhs=right-hand side, and op=operator<br>Propositions are reference by a rule or another proposition (in the case of compound propositions).<br>Propositions are never re-used across multiple rules.<br>Each proposition can have zero or more parameters. The proposition parameter is the primary <br>data element used to define the proposition.  (@see PropositionParameter)
<h2><a name="StructureDefinition"></a>Structure Definition</h2>
<table class="structTable">
<tr>
<th class="h">ShortName</th>
<th class="h">Name</th>
<th class="h">Type</th>
<th class="h">Description</th>
<th class="h">Required?</th>
<th class="h">Read only?</th>
<th class="h">Cardinality</th>
<th class="h">XML Attribute?</th>
<th class="h">Implementation Notes</th>
</tr>
<tr>
<td class="structSName">id</td>
<td class="structLName">Id</td>
<td class="structType">String</td>
<td class="structDesc">The unique identifier for an object.  This can be null.</td>
<td class="structOpt">Required</td>
<td class="structOpt">&nbsp;</td>
<td class="structCard">One</td>
<td class="structAttr">No</td>
<td class="commentsDesc">&nbsp;</td>
</tr>
<tr>
<td class="structSName">description</td>
<td class="structLName">Description</td>
<td class="structType">String</td>
<td class="structDesc">This is the description text for the KRMS proposition</td>
<td class="structOpt">Required</td>
<td class="structOpt">&nbsp;</td>
<td class="structCard">One</td>
<td class="structAttr">No</td>
<td class="commentsDesc">&nbsp;</td>
</tr>
<tr>
<td class="structSName">ruleId</td>
<td class="structLName">Rule Id</td>
<td class="structType">String</td>
<td class="structDesc">This returns the ID of the rule this proposition belongs to.  May be null if this proposition has <br>not yet been persisted.</td>
<td class="structOpt">Required</td>
<td class="structOpt">&nbsp;</td>
<td class="structCard">One</td>
<td class="structAttr">No</td>
<td class="commentsDesc">&nbsp;</td>
</tr>
<tr>
<td class="structSName">typeId</td>
<td class="structLName">Type Id</td>
<td class="structType">String</td>
<td class="structDesc">This is the id of Proposition KrmsType of the proposition.<br>It provides some context to what type of object of the KRMS type.</td>
<td class="structOpt">Required</td>
<td class="structOpt">&nbsp;</td>
<td class="structCard">One</td>
<td class="structAttr">No</td>
<td class="commentsDesc">&nbsp;</td>
</tr>
<tr>
<td class="structSName">propositionTypeCode</td>
<td class="structLName">Proposition Type Code</td>
<td class="structType">String</td>
<td class="structDesc"><p><br>There are three main types of Propositions:<br>  Compound Propositions - a proposition consisting of other propositions <br>  	and a boolean algebra operator (AND, OR) defining how to evaluate <br>  	those propositions.<br>  Parameterized Propositions - a proposition which is parameterized by <br>     some set of values, evaluation logic is implemented by hand and <br>     returns true or false<br>  Simple Propositions - a proposition of the form lhs op rhs where <br>  	lhs=left-hand side, rhs=right-hand side, and op=operator<br></p></td>
<td class="structOpt">Required</td>
<td class="structOpt">&nbsp;</td>
<td class="structCard">One</td>
<td class="structAttr">No</td>
<td class="commentsDesc">&nbsp;</td>
</tr>
<tr>
<td class="structSName">parameters</td>
<td class="structLName">Parameters</td>
<td class="structType"><a href="PropositionParameter.html">PropositionParameterList</a>
</td><td class="structDesc">This is the parameter list of the proposition.<br>Parameters are listed in Reverse Polish Notation.<br>Parameters may be constants, terms, or functions.<br><p><br>Compound Propositions will have an empty parameter list.<br></p></td>
<td class="structOpt">&nbsp;</td>
<td class="structOpt">&nbsp;</td>
<td class="structCard">Many</td>
<td class="structAttr">No</td>
<td class="commentsDesc">&nbsp;</td>
</tr>
<tr>
<td class="structSName">compoundOpCode</td>
<td class="structLName">Compound Op Code</td>
<td class="structType">String</td>
<td class="structDesc">This method returns the op code to be used when evaluating compound<br>propositions.</td>
<td class="structOpt">&nbsp;</td>
<td class="structOpt">&nbsp;</td>
<td class="structCard">One</td>
<td class="structAttr">No</td>
<td class="commentsDesc">&nbsp;</td>
</tr>
<tr>
<td class="structSName">compoundComponents</td>
<td class="structLName">Compound Components</td>
<td class="structType"><a href="PropositionDefinition.html">PropositionDefinitionList</a>
</td><td class="structDesc">This method returns the propositions which are contained in a<br>compound proposition.</td>
<td class="structOpt">&nbsp;</td>
<td class="structOpt">&nbsp;</td>
<td class="structCard">Many</td>
<td class="structAttr">No</td>
<td class="commentsDesc">&nbsp;</td>
</tr>
<tr>
<td class="structSName">versionNumber</td>
<td class="structLName">Version Number</td>
<td class="structType">Long</td>
<td class="structDesc">Returns the version number for this object.  In general, this value should only<br>be null if the object has not yet been stored to a persistent data store.<br>This version number is generally used for the purposes of optimistic locking.</td>
<td class="structOpt">&nbsp;</td>
<td class="structOpt">&nbsp;</td>
<td class="structCard">One</td>
<td class="structAttr">No</td>
<td class="commentsDesc">&nbsp;</td>
</tr>
</table>

</body>
</html>
